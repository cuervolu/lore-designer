# Lore Designer Architecture

> [!WARNING]
> I'm working on this document on my free time, so it may take a while to be completed. Please be patient. The current version explains the high-level architecture and some design decisions.

So, you really want to know how Lore Designer works, don't you? Well, this guide will explain the reasoning behind each decision and how I made them. It's a somewhat long document, so grab a coffee and sit down while I explain.

You may have already noticed, but Lore Designer, in essence, is not a native application—it's a web application packaged as a desktop app. This is thanks to Tauri, which, unlike Electron, doesn't bundle the entire Chromium with your app. Tauri uses the operating system's WebView to render content. This brings certain advantages and disadvantages.
```
┌─────────────────────────────────────────────────────────────┐
│                     Lore Designer                           │
│  ┌───────────────────────────────────────────────────────┐  │
│  │           Frontend (Vue.js + TypeScript)              │  │
│  │                                                       │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────────────┐     │  │
│  │  │   UI     │  │  State   │  │  Tauri Commands  │     │  │
│  │  │Components│  │Management│  │  (IPC Calls)     │     │  │
│  │  └──────────┘  └──────────┘  └──────────────────┘     │  │
│  └───────────────────────────────────────────────────────┘  │
│                            │                                │
│                    ┌───────▼────────┐                       │
│                    │   Tauri IPC    │                       │
│                    └───────┬────────┘                       │
│  ┌─────────────────────────▼─────────────────────────────┐  │
│  │         Backend (Rust)                                │  │
│  │                                                       │  │
│  │  ┌─────────────┐  ┌──────────────┐  ┌────────────┐    │  │
│  │  │   lore-     │  │     lore-    │  │   tauri-   │    │  │
│  │  │ workspaces  │  │    editor    │  │   plugin-  │    │  │
│  │  │             │  │              │  │   tracing  │    │  │
│  │  └─────────────┘  └──────────────┘  └────────────┘    │  │
│  └───────────────────────────────────────────────────────┘  │
│                            │                                │
│                    ┌───────▼────────┐                       │
│                    │  OS WebView    │                       │
│                    │ (WebKit/Edge)  │                       │
│                    └────────────────┘                       │
└─────────────────────────────────────────────────────────────┘
```

An advantage is that the app ends up being lighter, but another is that its behavior varies between systems. For example, it's very likely that on certain Linux distributions, Lore Designer won't run as well as on Windows or macOS (even though most of the development was done on Arch Linux). This is because the WebView that Tauri uses on Linux isn't as efficient as the one used on Windows or macOS.

Another possible problem is that some users might not be able to install the app if they don't have the WebView installed. This would be rare, since it normally comes with the OS, but on some older versions it might not. Tauri can solve this by bundling the WebView with your app, but it's optional and increases the bundle size. Lore Designer does not do this.

Tauri allows us to use Rust on the backend and connect to the frontend via IPC, which can be any framework you want, as long as you run it on the client. In this case, we use Vue. Not for any advantage or anything like that. Simply because Vue is my favorite framework.

Could I have chosen something other than Tauri? Yes, and it was considered. I thought about several options:

- Avalonia UI
- UnoPlatform
- Flutter
- Kotlin Multiplatform (at the time it was just coming out)

But I went with Tauri for speed of development, familiarity, the DX, and the fact that JS has several dependencies that would make some of Lore Designer's features easier to implement with the limited time I had.

## High-Level Architecture

Lore Designer works without needing any cloud backend or anything like that. It can work without internet without problems. And if you checked the different files in the project, you'll notice it's divided into a monorepo.
```
lore-designer/
├── apps/
│   ├── desktop/              ← Main Tauri application
│   │   ├── src/              ← Vue.js frontend
│   │   ├── src-tauri/        ← Rust backend (Tauri commands)
│   │   └── package.json
│   └── docs/                 ← Marketing & documentation site
├── packages/                 ← Shared utilities (future)
└── plugins/
    └── tauri-plugin-tracing/ ← Custom logging plugin
```

Initially, the project was a single one, the typical app generated by the Tauri CLI. As I needed to add features and facilitate my development, it changed to a monorepo.

For example, the latest addition was the tracing plugin I made. I know Tauri has its own plugin for logs, but it didn't serve what Lore Designer needed: to show logs in the console and in the WebView at the same time.

Also, for compilation speed, `src-tauri` was divided into different crates in a modular way:
```
lore-designer/
├── Cargo.toml   ← Workspace manifest
├── crates/
│   ├── lore-workspaces/  ← File system management
│   │   ├── src/
│   │   │   ├── lib.rs       ← Workspace CRUD operations
│   │   │   └── manifest.rs  ← .lore file handling
│   │   └── Cargo.toml
│   └── lore-editor/     ← Editor logic & state
│       ├── src/
│       │   ├── index.rs     ← File indexing system
│       │   ├── editor.rs   ← Editor workflow logic
│       │   └── model.rs    ← Character, Location types
│       └── Cargo.toml
└── apps/
    └── desktop/        ← Main Tauri application
        └── src-tauri/ ← Rust backend (Tauri commands)
            ├── core/
            │   └── error.rs ← Common error types
            ├── lib.rs      ← Tauri entry point
            └── main.rs    ← Application setup
```


**lore-workspaces** handles everything related to workspace management. It deals with files as such—what a project essentially is. **lore-editor** handles actions that happen within a project, such as creating characters or indexing the workspace. It doesn't know what a file is, but it knows what they contain.
```
Responsibility Separation:

┌─────────────────────────────────────────────────────────┐
│              lore-workspaces                            │
│  "I know what files ARE"                                │
│                                                         │
│  • Create/delete/move files                             │
│  • Read/write file content                              │
│  • Manage workspace structure                           │
│  • Handle .lore manifest (TOML)                         │
│  • Validate paths & permissions                         │
│  • Cross-platform file operations                       │
└─────────────────────────────────────────────────────────┘
                         │
                         │ Uses
                         ▼
┌─────────────────────────────────────────────────────────┐
│              lore-editor                                │
│  "I know what files CONTAIN"                            │
│                                                         │
│  • Parse YAML frontmatter                               │
│  • Index characters, locations, lore                    │
│  • Manage editor state & sessions                       │
│  • Handle relationships between entities                │
│  • Search & filter content                              │
│  • Doesn't touch file I/O directly                      │
└─────────────────────────────────────────────────────────┘
```

When you create a workspace, a Tauri command is executed that calls Rust logic. This command creates the workspace structure based on the template selected in the form, and then the frontend, upon receiving the result of this command, takes you to the editor or shows you an error message depending on whether it was successful or not.
```
Workspace Creation Flow:

┌──────────────┐
│   Frontend   │
│   (Vue.js)   │
└──────┬───────┘
       │
       │ 1. User fills form & clicks "Create"
       │
       ▼
┌──────────────────────────────────────────────────────────┐
│  invoke('create_workspace', {                            │
│    name: "My Novel",                                     │
│    path: "/home/user/projects",                          │
│    template: "novel"                                     │
│  })                                                      │
└──────┬───────────────────────────────────────────────────┘
       │
       │ 2. IPC call to Rust
       │
       ▼
┌──────────────────────────────────────────────────────────┐
│  Tauri Command Handler (src/commands/workspace.rs)      │
│                                                          │
│  #[tauri::command]                                       │
│  async fn create_workspace(...)                          │
└──────┬───────────────────────────────────────────────────┘
       │
       │ 3. Calls business logic
       │
       ▼
┌──────────────────────────────────────────────────────────┐
│  lore-workspaces::workspace::create()                    │
│                                                          │
│  • Validate path                                         │
│  • Create directory structure                            │
│  • Generate .lore manifest (TOML)                        │
│  • Apply template (copy files)                           │
│  • Initialize .lore/ folder                              │
└──────┬───────────────────────────────────────────────────┘
       │
       │ 4. Returns Result<WorkspaceManifest, WorkspaceError>
       │
       ▼
┌──────────────────────────────────────────────────────────┐
│  Frontend receives result                                │
│                                                          │
│  • Success → Navigate to /editor                         │
│  • Error → Show toast notification                       │
└──────────────────────────────────────────────────────────┘
```
